# Requirements Document

## Introduction

This specification adds macOS desktop notifications to agent-repl. When enabled,
the system sends a notification via macOS Notification Center when the agent
completes a response, encounters an error, or finishes a tool execution â€” but
only if the terminal is in the background and the interaction has exceeded a
configurable time threshold. Notifications are delivered via `osascript` (zero
additional dependencies). The architecture uses a platform-abstraction layer so
future platforms (Linux, Windows) can be added without modifying the core logic.

## Glossary

| Term | Definition |
|------|------------|
| Notification | A macOS Notification Center banner displayed to the user |
| Notification backend | Platform-specific mechanism for delivering notifications (e.g., osascript on macOS) |
| Null backend | A no-op backend used on unsupported platforms |
| Foreground detection | Checking whether the terminal application is the frontmost (active) window |
| Time threshold | Minimum elapsed time since the agent turn started before notifications are eligible to fire |
| Debounce | Buffering rapid notification events so that only one notification is delivered per quiet period |
| Debounce window | The number of seconds to wait after a notification-worthy event before delivering it; resets if a new event arrives |
| Turn start time | The monotonic timestamp recorded when `handle_stream()` begins processing a new agent response |
| Notification-worthy event | A stream event that can trigger a notification: response complete, error, or tool result |

## Requirements

### Requirement 1: Notification Configuration

**User Story:** As a library consumer, I want to configure notification behavior via a config file so that notifications work out of the box for my users when enabled.

#### Acceptance Criteria

1. THE `types.py` module SHALL define a `NotificationConfig` dataclass with fields: `enabled` (bool, default `False`), `sound` (str | None, default `"default"`), `threshold_seconds` (int, default `60`), `debounce_seconds` (float, default `5.0`).
2. THE `Config` dataclass SHALL include a `notifications` field of type `NotificationConfig` with a default-constructed value.
3. WHEN a `[notifications]` section exists in `.af/config.toml`, THE system SHALL parse it and construct a `NotificationConfig` from its keys.
4. WHEN `threshold_seconds` in the config file is less than 60, THE system SHALL clamp it to 60.
5. WHEN the `[notifications]` section is missing from `.af/config.toml`, THE system SHALL use the default `NotificationConfig` (notifications disabled).
6. THE default config template generated by `config_loader.py` SHALL include a commented-out `[notifications]` section showing all available keys.

#### Edge Cases

1. IF `[notifications]` contains unknown keys, THEN THE system SHALL ignore them without warning.
2. IF `[notifications]` contains values of the wrong type (e.g., `enabled = "yes"`), THEN THE system SHALL log a warning and use the default `NotificationConfig`.

---

### Requirement 2: Notification Slash Command

**User Story:** As a user, I want to toggle notifications on and off during my session with a `/notify` command so that I can enable them when I start a long task.

#### Acceptance Criteria

1. THE system SHALL register a `/notify` slash command in `BuiltinCommandsPlugin`.
2. WHEN the user invokes `/notify` AND notifications are off, THE system SHALL enable notifications and display: "Notifications enabled."
3. WHEN the user invokes `/notify` AND notifications are on, THE system SHALL disable notifications and display: "Notifications disabled."
4. THE `/notify` command SHALL NOT persist the toggle state to the config file; it is runtime-only.
5. THE `/notify` command SHALL be CLI-exposed (`cli_exposed=True`).

#### Edge Cases

1. IF `/notify` is invoked and the `Notifier` is not wired (None), THEN THE system SHALL display an error: "Notifier not available."
2. IF `/notify` is invoked on a platform where no backend is available, THE system SHALL still toggle the enabled state (the backend handles the no-op silently).

---

### Requirement 3: Notification Triggers

**User Story:** As a user, I want to be notified when the agent finishes a response, encounters an error, or completes a tool execution so that I can switch back to the terminal.

#### Acceptance Criteria

1. WHEN the agent response stream completes (all events processed in `handle_stream()`), THE system SHALL queue a notification with a snippet of the response text (first 80 characters, or "Response complete" if no text).
2. WHEN an `ERROR` stream event is received, THE system SHALL queue a notification with the error message (truncated to 80 characters).
3. WHEN a `TOOL_RESULT` stream event is received, THE system SHALL queue a notification with the text "Tool completed: {tool_name}".
4. WHEN `handle_stream()` finishes, THE system SHALL flush any pending debounced notification immediately.

#### Edge Cases

1. IF the response text is empty and no tools were used, THEN THE notification message SHALL be "Response complete".
2. IF an `ERROR` event has `fatal=True`, THEN THE notification SHALL still be queued before the stream breaks.
3. IF the stream yields only `USAGE` events (no text, tools, or errors), THEN THE system SHALL NOT queue any notification.

---

### Requirement 4: Time Threshold Guard

**User Story:** As a user, I want notifications only for long-running interactions so that quick responses don't spam my desktop.

#### Acceptance Criteria

1. WHEN `handle_stream()` begins, THE system SHALL record the current monotonic time as the turn start time.
2. WHEN a notification-worthy event is queued, THE system SHALL check whether the elapsed time since turn start exceeds `NotificationConfig.threshold_seconds`.
3. IF the elapsed time is less than `threshold_seconds`, THEN THE system SHALL discard the notification silently.
4. THE minimum allowed value for `threshold_seconds` SHALL be 60 (enforced during config parsing).

#### Edge Cases

1. IF the system clock is adjusted during a turn (NTP sync), THE threshold check SHALL still work correctly because it uses monotonic time.
2. IF `threshold_seconds` is set to exactly 60, THEN notifications SHALL fire for interactions lasting 60 seconds or more.

---

### Requirement 5: Debounce Buffer

**User Story:** As a user, I want rapid tool completions to produce a single notification rather than a burst of banners.

#### Acceptance Criteria

1. WHEN the first notification-worthy event is queued and passes the threshold check, THE system SHALL start a debounce timer of `debounce_seconds` duration.
2. IF another notification-worthy event arrives before the timer expires, THE system SHALL replace the pending notification content and restart the timer.
3. WHEN the debounce timer expires without a new event, THE system SHALL deliver the pending notification.
4. WHEN `handle_stream()` finishes (stream complete), THE system SHALL cancel any active debounce timer and deliver the pending notification immediately.
5. THE debounce timer SHALL be implemented as an `asyncio.Task` so it does not block the event loop.

#### Edge Cases

1. IF the debounce timer is cancelled (stream ends) before it fires, THEN THE pending notification SHALL be delivered by `flush()`.
2. IF no notification-worthy events pass the threshold check, THEN no debounce timer SHALL be started.

---

### Requirement 6: Foreground Detection

**User Story:** As a user, I want notifications suppressed when I'm already looking at the terminal so that banners don't obscure my view.

#### Acceptance Criteria

1. BEFORE delivering a notification, THE system SHALL check whether the terminal application is the frontmost (active) macOS application.
2. IF the terminal is the frontmost application, THEN THE system SHALL suppress the notification silently.
3. THE foreground check SHALL use `AppKit.NSWorkspace.sharedWorkspace().frontmostApplication().bundleIdentifier()` to identify the frontmost app.
4. THE system SHALL recognize at least these terminal bundle IDs: `com.apple.Terminal`, `com.googlecode.iterm2`, `dev.warp.Warp-Stable`, `com.mitchellh.ghostty`.
5. IF `AppKit` is not importable (non-framework Python, virtualenv without PyObjC), THEN THE system SHALL skip the foreground check and always deliver the notification.

#### Edge Cases

1. IF the frontmost application's bundle identifier is `None`, THEN THE system SHALL treat it as "not a terminal" and deliver the notification.
2. IF the user's terminal is not in the recognized list, THEN THE system SHALL deliver notifications even when that terminal is in the foreground.

---

### Requirement 7: macOS Notification Delivery

**User Story:** As a macOS user, I want desktop notifications delivered via the native Notification Center without installing extra dependencies.

#### Acceptance Criteria

1. THE macOS backend SHALL send notifications using `subprocess.run(["osascript", "-e", script])` with a 5-second timeout.
2. THE `osascript` invocation SHALL be run via `asyncio.get_running_loop().run_in_executor(None, ...)` to avoid blocking the event loop.
3. THE AppleScript SHALL use the `display notification` command with `title`, `message`, and optionally `sound name` parameters.
4. THE notification title SHALL be the application name from `Config.app_name`.
5. THE notification message SHALL be the content string provided by the caller (already truncated to 80 characters).
6. WHEN `NotificationConfig.sound` is not None, THE AppleScript SHALL include `sound name "{sound}"`.
7. WHEN `NotificationConfig.sound` is None, THE AppleScript SHALL omit the `sound name` clause.
8. THE macOS backend SHALL properly escape AppleScript string literals (backslashes and double quotes).

#### Edge Cases

1. IF the `osascript` command fails (non-zero exit code), THEN THE system SHALL log a warning and continue without crashing.
2. IF the `osascript` command times out (>5s), THEN THE system SHALL log a warning and continue without crashing.
3. IF the notification message contains special characters (quotes, backslashes, newlines), THEN THE AppleScript escaping SHALL prevent script injection.

---

### Requirement 8: Platform Abstraction

**User Story:** As a library developer, I want the notification system designed for future cross-platform support so that adding Linux/Windows backends later doesn't require rearchitecting.

#### Acceptance Criteria

1. THE system SHALL define a `NotificationBackend` protocol with methods: `is_available() -> bool` and `send(title: str, message: str, sound: str | None) -> None`.
2. THE system SHALL implement `MacOSBackend` conforming to `NotificationBackend`.
3. THE system SHALL implement `NullBackend` conforming to `NotificationBackend`, where `is_available()` returns `False` and `send()` is a no-op.
4. WHEN `platform.system()` returns `"Darwin"`, THE system SHALL use `MacOSBackend`.
5. WHEN `platform.system()` returns anything other than `"Darwin"`, THE system SHALL use `NullBackend`.
6. THE `Notifier` class SHALL interact only with the `NotificationBackend` protocol, never with platform-specific code directly.

#### Edge Cases

1. IF `MacOSBackend.is_available()` is called and `osascript` is not found on the PATH, THEN it SHALL return `False`.
2. IF `NullBackend.send()` is called, THEN it SHALL perform no I/O and return immediately.
